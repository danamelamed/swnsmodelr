---
title: "Vignette"
author: "Dana Melamed"
date: "April 30, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(eval = FALSE)
knitr::opts_knit$set(root.dir = 'F:\\swnsmodelr')
#install.packages('randomcoloR')
library(swnsmodelr)
```

## Selecting Rasters as Inputs

Rasters of physical properties of the environment that are constant through time are referred to as "constant rasters" in the package. Examples of these rasters, that are provided as extra data, are the elevation, aspect, slope, proximity to coast line, easting and northing values of the region. Since the values from these rasters do not change over time, they only need to be extracted to the weather station points once. In this section is an overview of how to select and manipulate these rasters.

### Transform Aspect Values

Create the aspect rasters as per Guan et al, 2013

```{r transform aspect, eval = FALSE}
# as per Guan et al 2013
rasters_dir <- file.path('F:','data','rasters','input_rasters')
resolutions = list(20,100,200,700,1000)
for(resolution in resolutions){
for(raster in rasters_list){
if(yres(raster)== resolution){
  if(substring(names(raster),1,3)== 'asp'){
  
    asp <- raster
   
  }
  if(substring(names(raster),1,3)== 'slp'){
    slp <- raster
  }
}
}
aspg <- slp*cos(asp)
#writeRaster(aspg, file.path(rasters_dir,paste0('aspg',resolution,'m.tif')),
#            overwrite = TRUE)
}

```





### Bring Constant Rasters into R Environment

Throughout the modelling workflow provided in the swnsmodelr package, the constant rasters should be in the form of raster objects in a list. Rasters have been provided in the swnsmodelr project. Selecting rasters from the project folder and storing them as a list of raster objects can be done with the following code:
```{r create rasters_list, results = "hide", error = FALSE}
# See list of rasters in Rasters project folder


# Store names of rasters from list
rasters_dir <- file.path('F:','data','rasters','input_rasters')
rasters_names_list <- c("dem","tpi300m",'tpi2000m','tpi5000m',
                        "aspg","east","north","cp","slp")
resolutions <- c('20m','100m','200m','700m','1000m')

all_rasters <-  file.path(rasters_dir,paste0(as.list(outer(rasters_names_list,resolutions,paste0)),'.tif'))

rasters_list <- list()
c <- 1
for(raster in all_rasters){
  try({rasters_list[[c]] <- raster(raster)
       c <- c+1
       }) 
}

```



### Bring Temporal Rasters into R Environment
This stage requires two steps. In the first step, using `swnsmodelr::make_temporal_rasters_df()` the paths for all the temporal rasters are stored in a dataframe, with their corresponding date. This data frame is called the temporal rasters dataframe. In the second step, the temporal rasters dataframe is used to point to rasters, and extract their values to the `stations_df`. Here, the temporal rasters dataframe is called `solar_irradiance_rasters_df`.

```{r temporal rasters, message = FALSE}
resolutions = c('20m','100m','200m','700m','1000m')
for(res in resolutions){
  
solar_irradiance_rasters_df <- make_temporal_raster_df(
  in_folder = paste0("F:\\GOES\\",res),
  start_date = ymd('2012-01-01'),
  end_date   = ymd('2017-12-31'),
  date_chars = c(16,-5),
  date_format = "%Y_%j",
  extension = ".tif")
df <- extract_temporal_raster_values(solar_irradiance_rasters_df,
                                    swns_stations_df,
                                    paste0('solar',res))
col_name = paste0('solar',res)
swns_stations_df <- swns_stations_df %>% mutate( df[length(df)])

}

```



Extract values of constant rasters at stations to a dataframe.


```{r extract constant rasters}
swns_stations_df <- extract_constant_raster_values(swns_stations_df,
                                              rasters_list)


```  


melt
```{r melt dataframe}
swns_stations_melt_df <- reshape2::melt(swns_stations_df, id.vars = c('stationid','date_time','temp_min','temp_max','temp_mean','EASTING','NORTHING'))
swns_stations_vars_df <-  stations_melt_df %>% 
  mutate(var = ifelse(grepl('dem',variable),'dem','')) %>%
  mutate(var = ifelse(grepl('tpi300m',variable),'tpi300m',var)) %>%
  mutate(var = ifelse(grepl('tpi2000m',variable),'tpi2000m',var)) %>%
  mutate(var = ifelse(grepl('tpi5000m',variable),'tpi5000m',var)) %>%
  mutate(var = ifelse(grepl('aspg',variable),'aspg',var)) %>%
  mutate(var = ifelse(grepl('east',variable),'east',var)) %>%
  mutate(var = ifelse(grepl('north',variable),'north',var)) %>%
  mutate(var = ifelse(grepl('slp',variable),'slp',var)) %>%
  mutate(var = ifelse(grepl('cp',variable),'cp',var)) %>%
  mutate(var = ifelse(grepl('solar',variable),'solar',var)) %>%
  mutate(res = ifelse(grepl('20',variable),'20','')) %>%
   mutate(res = ifelse(grepl('100',variable),'100',res)) %>%
   mutate(res = ifelse(grepl('200',variable),'200',res)) %>%
   mutate(res = ifelse(grepl('700',variable),'700',res)) %>%
  mutate(res = ifelse(grepl('1000',variable),'1000',res)) 

```



### Exploratory Data Analysis

#### Raster values 

Check out raster statistics as a table
```{r raster statistics}
rasters_names_list <- c("dem","slp","aspg","cp","tpi300m","tpi2000m","tpi5000m","north","east")
df <- data.frame(names = character(),min=double(),mean=double(),max=double())
c <- 0
for(raster_name in rasters_names_list){
  names_list <- list()

  for(raster in rasters_list){
   
    if(substring(names(raster),1,3) == substring(raster_name,1,3)){
      
      if(substring(names(raster),1,3) == 'tpi'){
        if(substring(names(raster),1,4) == substring(raster_name,1,4)){
          
          name <- names(raster)
          max<-cellStats(raster,'max')
          min<-cellStats(raster,'min')
          mean<-cellStats(raster,'mean')
          df[nrow(df) + 1,] <- c(name,min,mean,max)
           c <- c +1
        }
      }else{
        name <- names(raster)
          max<-cellStats(raster,'max')
          min<-cellStats(raster,'min')
          mean<-cellStats(raster,'mean')
          df[nrow(df) + 1,] <- c(name,min,mean,max)
           c <- c +1
          
      }
      
    }
    
    if(substring(names(raster),1,2) == 'cp'){
      if(substring(names(raster),1,2) == substring(raster_name,1,2)){
       name <- names(raster)
          max<-cellStats(raster,'max')
          min<-cellStats(raster,'min')
          mean<-cellStats(raster,'mean')
          df[nrow(df) + 1,] <- c(name,min,mean,max)
           c <- c +1 
      }
    }
    
   
  }
  
  
}

#write.csv(df, 'd:\\data\\raster_stats.csv')
```




Check out histograms of the raster values. Compare between different resolutions.
```{r, echo = FALSE, eval =FALSE}

# # get all rasters as list of lists
variables <- list('dem','slp','aspg','cp','tpi300m','tpi2000m','tpi5000m','north','east')

raster_lists <- list()
for(j in 1:length(variables)){

  if(variables[j]=='tpi300m'){
    resolutions <- list('20','100','200')
  }else{
    resolutions <- list('20','100','200','700','1000')
  }
  inner_list <- list()
  for(i in 1:length(resolutions)){

    inner_list[[i]] <-raster(paste0('f:\\data\\rasters\\input_rasters\\',variables[j],resolutions[i],'m.tif'))
  }
  raster_lists[[j]] <- inner_list
}



# create histograms for every raster... keep the bins the same as the 20m resolution raster
q <- list()
for(j in 1:length(raster_lists)){
  p <- list()
  
  
  for(i in 1:length(raster_lists[[j]])){
    if(i == 1){
      # get breaks
      h <- graphics::hist(getValues(raster_lists[[j]][[i]]), plot = FALSE, main = variables[[j]], nclass = 28)
      }
    
  
   tryCatch(
    expr = {m <- graphics::hist(getValues(raster_lists[[j]][[i]]), breaks = h$breaks
            , main = paste0(variables[[j]],resolutions[[i]]),xlab = 'Raster Cell Value',
            freq = FALSE)},
    error = function(e){ 
     # print(raster_lists[[j]][[i]]%>%names)
         m <- graphics::hist(getValues(raster_lists[[j]][[i]])
                  , main = paste0(variables[[j]],resolutions[[i]])
                  , xlab = 'Raster Cell Value'
                  , nclass = 28
                  , freq = FALSE)}
            )
    
  print(raster_lists[[j]][[i]]%>%names) 
  p[[i]] <- m
  }
  
 q[[j]] <- p   
}


```

Take a look at numbers from histograms

```{r}
# for each variable
df_list <- list()
c = 1
for(p in q){
  df <- data.frame(mids20m = p[[1]]$mids)

  try(df$var20m <- p[[1]]$counts/sum(p[[1]]$counts)*100)
  try(df$var100m <- p[[2]]$counts/sum(p[[2]]$counts)*100)
  try(df$var200m <- p[[3]]$counts/sum(p[[3]]$counts)*100)
  try(df$var700m <- p[[4]]$counts/sum(p[[4]]$counts)*100)
  try(df$var1000m <- p[[5]]$counts/sum(p[[5]]$counts)*100)
  df_list[[c]] <- df
  c <- c+ 1
  
}

for(df in df_list){
  print(kable(df, digits = 4))
}


```

Create histograms
```{r}
#for each df in the list
i <- 1
for(df in df_list){
      var = variables[i]
      print(ggplot(data = df, aes(x = mids20m, y = var20m))+
       geom_bar(stat='identity')+
        labs(y = 'Percentage', x = paste0(var,'20m')))
      print(ggplot(data = df, aes(x = mids20m, y = var100m))+
        geom_bar(stat='identity')+
        labs(y = 'Percentage', x = paste0(var,'100m')))
      print(ggplot(data = df, aes(x = mids20m, y = var200m))+
        geom_bar(stat='identity')+
        labs(y = 'Percentage', x = paste0(var,'200m')))
      try(print(ggplot(data = df, aes(x = mids20m, y = var700m))+
        geom_bar(stat='identity')+
        labs(y = 'Percentage', x = paste0(var,'700m'))))
      try(print(ggplot(data = df, aes(x = mids20m, y = var1000m))+
        geom_bar(stat='identity')+
        labs(y = 'Percentage', x = paste0(var,'1000m'))))
     i <- i+1
  
  }

```

##### Raster values  at weather stations
Ideally, weather stations would cover the full range of raster values. Also, compare between resolutions.
```{r , echo = FALSE}
library(swnsmodelr)
library(ggplot2)
in_df <- swns_new %>% filter(date_time == ymd('2012-06-01')) %>% 
    mutate(station = ifelse(stationid %in% nscc_stations_list,'nscc','ext'))
for(raster in rasters_list){
  col <- raster %>% names()
  df <- extract_constant_raster_values(in_df,list(raster)) %>% 
    arrange(.data[[col]])

  print(ggplot(data = df, aes(x = reorder(stationid, 1:length(df[[1]])), y = .data[[col]])) +
          geom_point(aes(fill = station, shape = station),size = 2.2, alpha = 0.8) +
          labs(x = 'Stations',y = .data[[col]], title = col) +
          scale_y_continuous(limits = c(cellStats(raster,min),cellStats(raster,max))) +
          scale_shape_manual(values=c(21,24))+
          
          theme(
            axis.text.x=element_blank(),
            panel.background = element_rect(fill='white', colour = 'grey'), #transparent panel bg
            #plot.background = element_rect(fill='white',colour ='white'), #transparent plot bg
            panel.grid.major.y =   element_line(color = 'grey'), #remove major gridlines
            panel.grid.major.x = element_blank(), #remove minor gridlines
            #legend.background = element_rect(fill='transparent'), #transparent legend bg
            legend.box.background = element_rect(fill='transparent',colour='grey'), #transparent legend panel
            legend.key = element_rect(colour = 'grey', fill = NA)
          ) 
          

  
  )
  
  
}

```


##### Maximum and minimum raster values at weather stations
What are the maximum and minimum values covered by weather stations for each raster?
```{r}
options(scipen=999)
# get weather station values for a single day
df <- stations_vars_df %>% 
  # filter(stationid %in% nscc_stations_list) %>%
  filter(date_time == ymd('2012-08-01'))
df_max <- df  %>%
  group_by(variable) %>%
  slice_max(value) %>%
  ungroup() 

df_min <- df   %>%
  group_by(variable) %>%
  slice_min(value) %>%
  ungroup() 


df_out <- bind_rows(df_max,df_min)

```

##### Temperature values over the year
Check out the temperatures recorded at each station over the year, for each year.
```{r}

for(station_now in stations_df$stationid %>% unique()){
print(ggplot(data = stations_df %>% filter(stationid == station_now), aes(x = yday, y = temp_mean)) +
        geom_smooth(aes(colour = year_factor)) +
        labs(title=station_now)
      )

}

```


### Model the temperatures

#### Define the model
```{r}
df <- swnsmodelr::swns_stations_df %>% add_date_columns() %>% filter(stationid %in% swnsmodelr::nscc_stations_list)
# m1 <- tryCatch(
#     expr = {m <- gam(temp_mean ~ 
#            year + 
#            s(yday) + 
#            s(east200m, north200m) + 
#            s(east200) + 
#            s(north200m) +
#            s(dem200m) +
#            s(cp200m) +
#            s(tpi5000m200m)+
#            s(solar200m)
#            , data=df )},
#     error = function(e){ 
#      m <- gam(temp_mean ~ 
#            year + 
#            s(yday) + 
#            s(east200m, north200m) + 
#            s(east200m) + 
#            s(north200m) +
#            s(dem200m) +
#            s(cp200m) +
#            s(tpi5000m200m)
#            , data=df )
#      return(m)} 
# )
# 
# summary(m1)
# 

  m1 <- gam(temp_mean ~
           year +
           s(yday) +
           s(east200m) +
           s(north200m) +
           s(dem200m) +
           s(cp200m) 
           , data=df )
 
  
df <- df %>% filter(!is.na(solar200m))
     m2 <- gam(temp_mean ~
           year +
           s(yday) +
           s(east200m) +
           s(north200m) +
           s(dem200m) +
           s(cp200m)+
           s(solar200m)
           , data=df )

# summary(m2)

# m1 <- gam(temp_mean ~  
#             year +
#             s(yday) +
#            s(east200m) + 
#            s(north200m) +
#            s(dem200m) +
#            s(cp200m),
#             data=df )
# m2 <- gam(temp_mean ~  
#             year +
#             s(yday) +
#             s(east200m, north200m)+
#            s(east200m) + 
#            s(north200m) +
#            s(dem200m) +
#            s(cp200m),
#             data=df )
# 
# m3 <- gam(temp_mean ~  
#             year +
#             s(yday) +
#             s(solar200m)+
#            s(east200m) + 
#            s(north200m) +
#            s(dem200m) +
#            s(cp200m),
#             data=df )
# 
# m4 <- gam(temp_mean ~  
#             year +
#             s(yday) +
#             s(tpi2000m200m)+
#            s(east200m) + 
#            s(north200m) +
#            s(dem200m) +
#            s(cp200m),
#             data=df )
# m5 <- gam(temp_mean ~  
#             year +
#             s(yday) +
#             s(tpi300m200m)+
#            s(east200m) + 
#            s(north200m) +
#            s(dem200m) +
#            s(cp200m),
#             data=df )
# 
# summary(m1)
# summary(m2)
# summary(m3)

```
Check out residuals at validation (external) stations
```{r}
resid_df <- swnsmodelr::swns_stations_df %>% 
  filter(stationid %in% swnsmodelr::ext_stations_list) %>%
  add_date_columns()
resid_df <- add_residuals(resid_df,m1, var = "resid_m1") 
resid_df <- add_residuals(resid_df,m2, var = "resid_m2") 
resid_df <- add_residuals(resid_df,m3, var = "resid_m3") 
resid_df <- add_residuals(resid_df,m4, var = "resid_m4") 
resid_df <- add_residuals(resid_df,m5, var = "resid_m5") 
ggplot(data=resid_df %>% filter(year == 2012)) +
  #geom_smooth(aes(x=date_time, y=resid_m1),colour='blue') +
  #geom_smooth(aes(x=date_time, y=resid_m2),colour='red')  +
  geom_smooth(aes(x=date_time, y=resid_m3),colour='black') +
  geom_smooth(aes(x=date_time, y=resid_m4),colour='yellow')  +
  geom_smooth(aes(x=date_time, y=resid_m5),colour='orange')   
  
```


Create the raster brick
```{r}
resolution <- 200
today <- ymd('2012-08-01')
year_n <- year(today)
yday_n <- yday(today)

# grab constant rasters with given resolution
for(raster in rasters_list){
  print(raster %>% names())
  
  if(res(raster) == resolution){
    if(substring(names(raster),1,3)=='dem'){
      dem <- raster
      
      #Create date rasters
       year_raster <- dem * 0 + year_n
       names(year_raster) <- 'year'
       yday_raster <- year_raster*0 + yday_n
       names(yday_raster) <- 'yday'
       rasters_brick <- raster::brick(year_raster,yday_raster,dem)
       
      
    }else{
      rasters_brick <- raster::addLayer(rasters_brick,raster)
    }
    
    
  }
}



#Solar raster
solar_df <- make_temporal_raster_df(
  in_folder = paste0("F:\\GOES\\",resolution,'m'),
  start_date = ymd('2012-01-01'),
  end_date   = ymd('2017-12-31'),
  date_chars = c(16,-5),
  date_format = "%Y_%j",
  extension = ".tif")
df <- solar_df %>% filter(date_time == today)

try(solar_raster <- raster::raster(df$path_field[[1]]))
try(names(solar_raster) <- paste0('solar',resolution,'m'))
try(
  rasters_brick <- raster::addLayer(rasters_brick,solar_raster)
)

```
 
Predict with the gam using the raster brick, to generate a modelled raster.
```{r}
gam_raster <- raster::predict(rasters_brick,m1)
plot(gam_raster)

gam_raster <- raster::predict(rasters_brick,m2)
plot(gam_raster)
```


Calculate Daily GDD rasters from daily temperature mean rasters
```{r}
in_raster_folder <- "f://output//daily_mean//tpi_tests//tpi2000m200m//"
out_raster_folder <- "f://output//gdd5//tpi_tests//tpi2000m200m//"


# Calculate GDD5
t_base <- 5


years <- c('2012','2013','2014','2015','2016','2017')

df <- make_temporal_raster_df(in_raster_folder,
                              ymd('2012-01-01'),
                              ymd('2017-12-31'),c(11,20),'%Y-%m-%d')


for(year in years){
  year_df <- df %>% filter(year(date_time)==!!year)
  
  c=0
  for(raster_path in year_df[[1]]){
    
    raster_name <- basename(raster_path)
    new_name <- paste('gdd',5,substring(raster_name,
                                         11,
                                         nchar(raster_name)),
                      sep="_")
    
    mean_raster <- raster::raster(raster_path)
    gdd_raster <- mean_raster -t_base
    gdd_raster[gdd_raster < 0] <- 0
    if(c >0){
      gdd_raster <- acc_raster + gdd_raster
      
    }
    raster::writeRaster(gdd_raster,
                        file.path(out_raster_folder,new_name),
                        overwrite = TRUE)
    acc_raster <- gdd_raster
    
    
    
    c<-c+1
  }
}



```



Which solar days are missing?
```{r}
??

``